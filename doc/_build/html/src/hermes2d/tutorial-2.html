<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial Part II (Automatic Adaptivity) &mdash; Hermes2D Documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Hermes2D Documentation" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tutorial-part-ii-automatic-adaptivity">
<h1>Tutorial Part II (Automatic Adaptivity)<a class="headerlink" href="#tutorial-part-ii-automatic-adaptivity" title="Permalink to this headline">¶</a></h1>
<p>In the computations that we carried out so far, we have not paid any attention
to the accuracy of the results. In general, a computation on a fixed mesh is
not likely to be very accurate. There is a need for <em>adaptive mesh refinement
(AMR)</em> algorithms that improve the quality of the approximation by refining
mesh elements where the approximation is bad.</p>
<div class="section" id="adaptive-h-fem-and-hp-fem">
<h2>Adaptive h-FEM and hp-FEM<a class="headerlink" href="#adaptive-h-fem-and-hp-fem" title="Permalink to this headline">¶</a></h2>
<p>In traditional low-order FEM, refining an element is not algorithmically complicated,
and so the most difficult part is to find out what elements should be
refined. To do this, people employ various techniques ranging from rigorous
guaranteed a-posteriori error estimates to heuristic criteria such as residual
error indicators, error indicators based on steep gradients, etc. Unfortunately,
none of these approaches is suitable for Hermes: The rigorous guaranteed error
estimates only exist for very simple problems, such as linear elliptic PDEs,
and thus they are far from PDE-independent. Heuristic techniques are not
employed in Hermes for the same reason, and moreover since such criteria
lack a transparent relation to the true approximation error.</p>
<p>Adaptive low-order FEM is known to be notoriously ineffcient, and practitioners
are rightfully skeptical of it. The reason is illustrated here:</p>
<div align="center" class="align-center"><img alt="Typical convergence curves for adaptive linear FEM, quadratic FEM, and *hp*-FEM." class="align-center" src="src/hermes2d/img/lshape/conv_dof.png" style="width: 600px; height: 400px;" /></div>
<p>These convergence curves are typical representative examples, confirmed with
many numerical experiments of independent researchers, and supported with
theory. The horizontal axis shows (in linear scale) the number of degrees of freedom
(= size of the stiffness matrix) that increases during automatic adaptivity. The
vertical one shows the approximation error (in logarithmic scale). Note that in all
three cases, the error drops very fast during a short initial phase of the adaptive
computation. However, with both linear and quadratic FEM, the convergence slows
down dramatically as the adaptivity progresses. Note that the low-order FEM
is doomed to such slow convergence by its poor approximation properties -
an excellent adaptivity algorithm cannot improve it (and a bad
algorithm can make it even worse).</p>
<p>In order to obtain fast, usable adaptivity (the green curve), one
has to resort to adaptive <em>hp</em>-FEM. The <em>hp</em>-FEM takes advantage of two facts:</p>
<ul class="simple">
<li>Large high-degree elements approximate smooth parts of solution much better than small linear ones. We created the example &#8216;smooth&#8217; to illustrate this fact. Check it out, the results are impressive.</li>
<li>This holds the other way where the solution is not smooth.</li>
</ul>
<p>Automatic adaptivity in the <em>hp</em>-FEM is substantially different from adaptivity
in low-order FEM, since every element can be refined in many different ways.
The following figure shows several refinement candidates for a fourth-order element.</p>
<div align="center" class="align-center"><img alt="Examples of *hp*-refinements." class="align-center" src="src/hermes2d/img/refinements.png" style="width: 650px; height: 300px;" /></div>
<p>Due to the large number of refinement options, classical error estimators (that
provide a constant error estimate per element) cannot be used to guide automatic
<em>hp</em>-adaptivity. For this, one needs to know the <em>shape</em> of the
approximation error.</p>
<p>In analogy to the most successful adaptive ODE solvers,
Hermes uses a pair of approximations with different orders of accuracy to obtain
this information: <em>coarse mesh solution</em> and
<em>fine mesh solution</em>. The initial coarse mesh is read from the mesh file,
and the initial fine mesh is created through its global refinement both in
<span class="math">h</span> and <span class="math">p</span>.
The fine mesh solution is the approximation of interest both during the adaptive
process and at the end of computation. The coarse mesh
solution represents its low-order part.</p>
<p>Both these solutions are evolved during the adaptive process
in a PDE-independent manner, based on the discrepancies between global and local
orthogonal projections. (Sometimes we replace the global orthogonal projection with
the solve on the coarse mesh, the difference is negligible.)</p>
<p>The obvious disadvantage of this approach to adaptivity is its higher computational cost,
especially in 3D. We are aware of this fact and would not mind at all replacing it with
some cheaper technique (as long as it also is PDE-independent, works for elements of high
orders, and can be successfully used to guide <em>hp</em>-adaptivity).</p>
</div>
<div class="section" id="understanding-convergence-rates">
<h2>Understanding Convergence Rates<a class="headerlink" href="#understanding-convergence-rates" title="Permalink to this headline">¶</a></h2>
<p>Hermes provides convergence graphs for every adaptive computation. Therefore,
let us spend a short moment explaining their meaning.
The classical notion of <span class="math">O(h^p)</span> convergence rate is related to sequences of
uniform meshes with a gradually decreasing diameter <span class="math">h</span>. In <span class="math">d</span> spatial dimensions,
the diameter <span class="math">h</span> of a uniform mesh is related to the number of degrees of freedom <span class="math">N</span>
through the relation</p>
<div class="math">
<p><span class="math">h = O(N^{-p/d}).</span></p>
</div><p>Therefore a slope of <span class="math">-p/d</span> on the log-log scale means that <span class="math">err \approx O(N^{-p/d})</span>
or <span class="math">err \approx O(h^p)</span>. When local refinements are enabled, the meaning of <span class="math">O(h^p)</span>
convergence rate loses its meaning, and one should switch to convergence in terms of
the number of degrees of freedom (DOF) or CPU time - Hermes provides both.</p>
<div class="section" id="algebraic-convergence-of-adaptive-fem">
<h3>Algebraic convergence of adaptive <span class="math">h</span>-FEM<a class="headerlink" href="#algebraic-convergence-of-adaptive-fem" title="Permalink to this headline">¶</a></h3>
<p>When using elements of degree <span class="math">p</span>, the convergence rate of adaptive <span class="math">h</span>-FEM will not exceed the
one predicted for uniformly refined meshes (this can be explained using
mathematical analysis). Nevertheless, the convergence may be faster due to a different
constant in front of the <span class="math">h^p</span> term. This is illustrated in the following two figures,
both of which are related to a 2D problem with known exact solution. The first pair of
graphs corresponds to adaptive <span class="math">h</span>-FEM with linear elements. The slope on the log-log
graph is -1/2 which means first-order convergence, as predicted by theory.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="src/hermes2d/img/conv-intro/layer_h1.png" style="width: 600px; height: 450px;" /></div>
<p>The next pair of convergence graphs corresponds to adaptive <span class="math">h</span>-FEM with quadratic elements.
The slope on the log-log graph is -1, which means that the convergence is quadratic as
predicted by theory.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="src/hermes2d/img/conv-intro/layer_h2.png" style="width: 600px; height: 450px;" /></div>
<p>Note that one always should look at the end of the convergence curve, not at the
beginning. The automatic adaptivity in Hermes is guided with the so-called
<em>reference solution</em>, which is an approximation on a globally-refined mesh.
In early stages of adaptivity, the reference solution and in turn also the error
estimate usually are not sufficiently accurate to deliver the expected convergence
rates.</p>
</div>
<div class="section" id="exponential-convergence-of-adaptive-fem">
<h3>Exponential convergence of adaptive <span class="math">hp</span>-FEM<a class="headerlink" href="#exponential-convergence-of-adaptive-fem" title="Permalink to this headline">¶</a></h3>
<p>It is predicted by theory that adaptive <span class="math">hp</span>-FEM should attain
exponential convergence rate. This means that the slope of the
convergence graph is steadily increasing, as shown in the
following figure.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="src/hermes2d/img/conv-intro/aniso-hp.png" style="width: 600px; height: 450px;" /></div>
<p>While this often is the case with adaptive <span class="math">hp</span>-FEM, there are
problems whose difficulty is such that the convergence is not
exponential. Or at least not during a long pre-asymptotic
stage of adaptivity. This may happen, for example, when the solution
contains an extremely strong singularity. Then basically all error
is concentrated there, and all adaptive methods will do the same,
which is to throw into the singularity as many small low-order
elements as possible. Then the convergence of adaptive <span class="math">h</span>-FEM
and <span class="math">hp</span>-FEM may be very similar (usually quite poor).</p>
</div>
<div class="section" id="estimated-vs-exact-convergence-rates">
<h3>Estimated vs. exact convergence rates<a class="headerlink" href="#estimated-vs-exact-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Whenever exact solution is available, Hermes provides both
estimated error (via the reference solution) as well as the
exact error. Thus the user can see the quality of the
error estimate. Note that the estimated error usually is
slightly less than the exact one, but during adaptivity
they quickly converge together and become virtually identical.
This is shown in the figure below.</p>
<div align="center" class="align-center"><img alt="Convergence graph." class="align-center" src="src/hermes2d/img/conv-intro/layer-hp.png" style="width: 600px; height: 450px;" /></div>
</div>
</div>
<div class="section" id="electrostatic-micromotor-problem">
<h2>Electrostatic Micromotor Problem<a class="headerlink" href="#electrostatic-micromotor-problem" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/tree/HEAD:/tutorial/10-adapt">10-adapt</a>.</p>
<p>Let us demostrate the use of adaptive h-FEM and hp-FEM on a linear elliptic problem
concerned with the calculation of
the electrostatic potential in the vicinity of the electrodes of an electrostatic
micromotor. This is a MEMS device free of any coils, and thus resistive to
strong electromagnetic waves (as opposed to classical electromotors).
The following figure shows one half of the domain <span class="math">\Omega</span>
(dimensions need to be scaled with <span class="math">10^{-5}</span> and are in meters):</p>
<div align="center" class="align-center"><img alt="Computational domain for the micromotor problem." class="align-center" src="src/hermes2d/img/micromotor.png" style="width: 550px; height: 400px;" /></div>
<p>The subdomain <span class="math">\Omega_2</span> represents the moving part of the domain and the area bounded by <span class="math">\Gamma_2</span>
represents the electrodes that are fixed. The distribution of the electrostatic potential <span class="math">\varphi</span> is governed by the equation</p>
<div class="math">
<p><span class="math">-\nabla\cdot\left(\epsilon_r\nabla\varphi\right) = 0,</span></p>
</div><p>equipped with the Dirichlet boundary conditions</p>
<div class="math">
<p><span class="math">\varphi = 0 V \ \ \ \ \ \mbox{on}\ \Gamma_1,</span></p>
</div><div class="math">
<p><span class="math">\varphi = 50 V \ \ \ \ \mbox{on}\ \Gamma_2.</span></p>
</div><p>The relative permittivity <span class="math">\epsilon_r</span> is piecewise-constant, <span class="math">\epsilon_r = 1</span> in <span class="math">\Omega_1</span> and
<span class="math">\epsilon_r = 10</span> in <span class="math">\Omega_2</span>. The weak formulation reads</p>
<div class="math">
<p><span class="math">\int_\Omega \epsilon_r \nabla u \cdot \nabla v \dx = 0.</span></p>
</div><p>The varying parameter <span class="math">\epsilon_r</span> is handled by defining two bilinear forms in the code, one for
<span class="math">\Omega_1</span> and the other for <span class="math">\Omega_2</span>. These two areas are delimited by element markers 1 and 2 in
the mesh, and the two forms are assigned to the corresponding markers during the registration of
the forms:</p>
<div class="highlight-python"><pre>WeakForm wf(1);
wf.add_biform(0, 0, callback(biform1), SYM, 1);
wf.add_biform(0, 0, callback(biform2), SYM, 2);</pre>
</div>
<p>The principal part of the example is the main adaptivity loop. In each iteration, the coarse problem
is solved first:</p>
<div class="highlight-python"><pre>// solve the coarse problem
LinSystem ls(&amp;wf, &amp;solver);
ls.set_spaces(1, &amp;space);
ls.set_pss(1, &amp;pss);
ls.assemble();
ls.solve(1, &amp;sln_coarse);</pre>
</div>
<p>Next, the reference solution is computed on a globally refined copy of the mesh,
defining a temporary space with increased element orders and by assembling and solving an extra
linear system. However, for most problems, this can be automated using the class RefSystem, which
handles all the temporary reference meshes and spaces transparently. All it needs is a pointer
to the coarse LinSystem:</p>
<div class="highlight-python"><pre>// solve the fine mesh problem
RefSystem rs(&amp;ls);
rs.assemble();
rs.solve(1, &amp;sln_fine);</pre>
</div>
<p>The constructor of the RefSystem class admits two optional parameters where the user
can choose a different polynomial degree increment (default value 1)
and another element refinement (default value 1) - see the file
<a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/blob/HEAD:/src/refsystem.h">src/refsystem.h</a>:</p>
<div class="highlight-python"><pre>RefSystem(LinSystem* base, int order_increase = 1, int refinement = 1);</pre>
</div>
<p>In particular, one may want to use order_increase = 0 for h-adaptivity, and
order_increase = 2 or 3 at the very beginning of computation when the reference
mesh is still very coarse and thus the reference solution does not give a meaningful
error estimate.</p>
<p>In the third and last step of each iteration, we refine our mesh and polynomial degrees stored
in our space using a class called H1OrthoHP. This class offers two services: it is able to
calculate  the estimate of the overall error of the coarse solution in <span class="math">H^1</span> norm, and if the
error is too large, you can ask the class to <em>hp</em>-adapt your mesh and element orders optimally.</p>
<p>H1OrthoHP is initialized with the number of spaces in the problem and pointers to them.
The method calc_error() takes pointers to the coarse and reference solutions and returns</p>
<div class="math">
<p><span class="math">e = \frac{|| u - u_{ref} ||_{H^1}}{|| u_{ref} ||_{H^1}}.</span></p>
</div><p>In the code this looks as follows:</p>
<div class="highlight-python"><pre>H1OrthoHP hp(1, &amp;space);
double err_est = hp.calc_error(&amp;sln_coarse, &amp;sln_fine) * 100;</pre>
</div>
<p>Finally, if err_est is still above the threshold ERR_STOP, we perform one
adaptivity step:</p>
<div class="highlight-python"><pre>if (err_est &lt; ERR_STOP) done = true;
else {
  hp.adapt(THRESHOLD, STRATEGY, ADAPT_TYPE, ISO_ONLY, MESH_REGULARITY);
  ndof = assign_dofs(&amp;space);
  if (ndof &gt;= NDOF_STOP) done = true;
}</pre>
</div>
<p>The function adapt() accepts additional optional input parameters for more
advanced use - see the file
<a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/blob/HEAD:/src/adapt_ortho_h1.h">src/adapt_h1_ortho.h</a>
for more details.
The basic parameters THRESHOLD, STRATEGY, ADAPT_TYPE, ISO_ONLY and MESH_REGULARITY
have the following meaning: STRATEGY indicates which adaptive strategy we
want to use:</p>
<ul class="simple">
<li>STRATEGY == 0: Refine elements until sqrt(THRESHOLD) times total error is processed. If more elements have similar error refine all to keep the mesh symmetric.</li>
<li>STRATEGY == 1: Refine all elements whose error is bigger than THRESHOLD times maximum element error.</li>
<li>STRATEGY == 2: Refine all elements whose error is bigger than THRESHOLD.</li>
</ul>
<p>If ADAPT_TYPE == 0, <em>hp</em>-adaptivity is performed (default). If ADAPT_TYPE == 1,
the algorithm does <em>h</em>-adaptivity (fixed polynomial degrees of elements). This option is there
for comparison purposes. With ADAPT_TYPE == 2 the algorithm does pure <em>p</em>-adaptivity (element
geometries fixed). This option is there for completeness, adaptive <em>p</em>-FEM is not very
useful in practice.</p>
<p>The parameter ISO_ONLY determines whether quadrilateral elements
can be split anisotropically (into two elements). The parameter MESH_REGULARITY
specifies maximum allowed level of hanging nodes: -1 means arbitrary-level
hanging nodes (default), and 1, 2, 3, ... means 1-irregular mesh,
2-irregular mesh, etc. Hermes does not support adaptivity on regular meshes
because of its extremely poor performance.</p>
<p>It is a good idea to spend some time playing with these parameters to
get a feeling for adaptive <em>hp</em>-FEM. Also look at other adaptivity examples in
the examples/ directory: layer, lshape deal with elliptic problems and have
known exact solutions. So do examples screen, bessel for time-harmonic
Maxwell&#8217;s equations. These examples allow you to compare the error estimates
computed by Hermes with the true error. Examples crack, singpert show
how to handle cracks and singularly perturbed problems, respectively. There
are also more advanced examples illustrating automatic adaptivity for nonlinear
problems solved via the Newton&#8217;s method, adaptive multimesh <em>hp</em>-FEM,
adaptivity for time-dependent problems on dynamical meshes, etc.</p>
<p>But let&#8217;s return to the micromotor example for a moment again: The computation
starts with a very coarse mesh consisting of a few quadrilaterals, some
of which are moreover very ill-shaped. Thanks to the anisotropic refinement
capabilities of H1OrthoHP, the mesh quickly adapts to the solution
and elements of reasonable shape are created near singularities, which occur
at the corners of the electrode. Initially, all elements of the mesh
are of a low degree, but as the <em>hp</em>-adaptive process progresses, the elements
receive different polynomial degrees, depending on the local smoothness of the
solution.</p>
<p>The gradient was visualized using VectorView. We have
seen this in the previous section. We plug in the same solution for both vector
components, but specify that its derivatives should be used:</p>
<div class="highlight-python"><pre>gview.show(&amp;sln, &amp;sln, EPS_NORMAL, FN_DX_0, FN_DY_0);</pre>
</div>
<img align="left" alt="Solution - electrostatic potential :math:`\varphi` (zoomed)." class="align-left" src="src/hermes2d/img/motor-sln.png" style="width: 300px; height: 300px;" />
<img align="right" alt="Gradient of the solution :math:`E = -\nabla\varphi` and its magnitude (zoomed)." class="align-right" src="src/hermes2d/img/motor-grad.png" style="width: 300px; height: 300px;" />
<hr style="clear: both; visibility: hidden;"><div align="center" class="align-center"><img alt="Polynomial orders of elements near singularities (zoomed)." class="align-center" src="src/hermes2d/img/motor-orders.png" style="width: 300px; height: 300px;" /></div>
<p>Convergence graphs of adaptive h-FEM with linear elements, h-FEM with quadratic elements
and hp-FEM are shown below.</p>
<div align="center" class="align-center"><img alt="DOF convergence graph for tutorial example 10-adapt." class="align-center" src="src/hermes2d/img/example-10/conv_dof.png" style="width: 600px; height: 400px;" /></div>
<p>The following graph shows convergence in terms of CPU time.</p>
<div align="center" class="align-center"><img alt="CPU convergence graph for tutorial example 10-adapt." class="align-center" src="src/hermes2d/img/example-10/conv_cpu.png" style="width: 600px; height: 400px;" /></div>
</div>
<div class="section" id="the-multimesh-hp-fem">
<h2>The Multimesh hp-FEM<a class="headerlink" href="#the-multimesh-hp-fem" title="Permalink to this headline">¶</a></h2>
<p>In multiphysics PDE systems (or just PDE systems) it can happen that one
physical field (solution component) has a singularity or a boundary layer
where other fields are smooth. If one approximates all fields on the
same mesh, then the necessity to refine the mesh at the singularity
or boundary layer implies new degrees of freedom for the smooth fields
as well. This can be very wasteful indeed, as we will see in the next
example that deals with a simplified Fitzhugh-Nagumo system. But let us
first explain briefly the main idea of the multimesh discretization
method that we developed to circumvent this problem.</p>
<p>Hermes makes it possible to approximate them
on individual meshes. These meshes are not completely independent
of each other &#8211; they have a common coarse mesh that we call <em>master mesh</em>.
The master mesh is there for algorithmic purposes only, it may not
even be used for discretization purposes: Every mesh in the system
is obtained from it via an arbitrary sequence of elementary refinements.
This is illustrated in the following figure, where (A) is the master mesh,
(B) - (D) three different meshes (say, for a coupled problem with three
equations), and (E) is the virtual <em>union mesh</em> that is used for assembling.</p>
<div align="center" class="align-center"><img alt="Multimesh" class="align-center" src="src/hermes2d/img/multimesh/multimesh.png" style="width: 750px;" /></div>
<p>The union mesh is not constructed physically in the computer memory &#8211;
merely it serves as a hint to correctly transform integration points
while integrating over sub-elements of the elements of the existing meshes.
The following figure shows the integration over an element <span class="math">Q_k</span> of the
virtual union mesh, and what are the appropriate subelements of the
existing elements where this integration is performed:</p>
<div align="center" class="align-center"><img alt="Multimesh" class="align-center" src="src/hermes2d/img/multimesh/multimesh2.png" style="width: 600px;" /></div>
<p>As a result, the multimesh discretization of the PDE system is <em>monolithic</em>
in the sense that <em>no physics is lost</em> &#8211; all integrals in the
discrete weak formulations are evaluated exactly up to the error in the
numerical quadrature. In particular, we do not perform operator splitting
or commit errors while transferring solution data between different meshes.
The multimesh assembling in Hermes works with all meshes at the same time,
there is no such thing as interpolating or projecting functions between
different meshes. More details about this method can be found in the
corresponding <a class="reference external" href="http://science.atmoshome.net/science?_ob=MImg&amp;_imagekey=B6TYH-4X1J73B-V-8Y&amp;_cdi=5619&amp;_user=10&amp;_pii=S0377042709005731&amp;_orig=browse&amp;_coverDate=08%2F18%2F2009&amp;_sk=999999999&amp;view=c&amp;wchp=dGLbVzz-zSkWz&amp;md5=6552d3390232dcffc9ca97e9bb626fb0&amp;ie=/sdarticle.pdf">research article</a>.</p>
<div class="section" id="adaptivity-in-the-multimesh-hp-fem">
<h3>Adaptivity in the Multimesh hp-FEM<a class="headerlink" href="#adaptivity-in-the-multimesh-hp-fem" title="Permalink to this headline">¶</a></h3>
<p>In principle, the adaptivity procedure for single PDE could be extended
directly to systems of PDEs. In other words, two spaces can be passed into H1OrthoHP,
four solutions (two coarse, two reference) can be passed into calc_error_2(),
and finally, adapt can be called as before. In this way, error estimates in
<span class="math">H^1</span> norm are calculated for elements in both spaces independently and the
worst ones are refined. However, this approach is not optimal if the PDEs are
coupled, since an error caused in one solution component influences the errors
in other components and vice versa.</p>
<p>Recall that in elliptic problems the bilinear form <span class="math">a(u,v)</span> defines the energetic inner product,</p>
<div class="math">
<p><span class="math">(u,v)_e = a(u,v).</span></p>
</div><p>The norm induced by this product,</p>
<div class="math">
<p><span class="math">||u||_e = \sqrt{(u,u)_e},</span></p>
</div><p>is called the <em>energy norm</em>. When measuring the error in the energy norm
of the entire system, one can reduce the above-mentioned difficulties dramatically.
When calculating the error on an element, the energy norm accounts
also for the error caused by other solution components.</p>
<p>It is also worth mentioning that the adaptivity algorithm does not make distinctions
between various meshes. The elements of <em>all meshes in the system</em> are put into one
single array, sorted according to their estimated errors, and then the ones with the
largest error are refined. In other words, it may happen that all elements marked for refinement
will belong just to one mesh.</p>
</div>
</div>
<div class="section" id="simplified-fitzhugh-nagumo-system">
<h2>Simplified Fitzhugh-Nagumo System<a class="headerlink" href="#simplified-fitzhugh-nagumo-system" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/tree/HEAD:/tutorial/11-adapt-system">11-adapt-system</a>.</p>
<p>We consider a simplified version of the Fitzhugh-Nagumo equation.
This equation is a~prominent example of activator-inhibitor systems in two-component reaction-diffusion
equations, It describes a prototype of an excitable system (e.g., a neuron) and its stationary form
is</p>
<div class="math">
<p><span class="math">-d^2_u \Delta u - f(u) + \sigma v = g_1,\\
-d^2_v \Delta v - u + v = g_2.</span></p>
</div><p>Here the unknowns <span class="math">u, v</span> are the voltage and <span class="math">v</span>-gate, respectively,
The nonlinear function</p>
<div class="math">
<p><span class="math">f(u) = \lambda u - u^3 - \kappa</span></p>
</div><p>describes how an action potential travels through a nerve. Obviously this system is nonlinear.
In order to make it simpler for this tutorial, we replace the function <span class="math">f(u)</span> with just <span class="math">u</span>:</p>
<div class="math">
<p><span class="math">f(u) = u.</span></p>
</div><p>The original nonlinear version is the subject of a separate benchmark example.</p>
<p>Our computational domain is the square <span class="math">(-1,1)^2</span> and we consider zero Dirichlet conditions
for both <span class="math">u</span> and <span class="math">v</span>. In order to enable fair convergence comparisons, we will use the following
functions as the exact solution:</p>
<div class="math">
<p><span class="math">u(x,y) = \cos\left(\frac{\pi}{2}x\right) \cos\left(\frac{\pi}{2}y\right),\\
v(x,y) = \hat u(x) \hat u(y)</span></p>
</div><p>where</p>
<div class="math">
<p><span class="math">\hat u(x) = 1 - \frac{e^{kx} + e^{-kx}}{e^k + e^{-k}}</span></p>
</div><p>is the exact solution of the one-dimensional singularly perturbed
problem</p>
<div class="math">
<p><span class="math">-u'' + k^2 u - k^2 = 0</span></p>
</div><p>in <span class="math">(-1,1)</span>, equipped with zero Dirichlet boundary conditions. The functions <span class="math">u</span>
and <span class="math">v</span> defined above evidently satisfy the given boundary conditions, and
they also satisfy the equation, since we inserted them into the PDE system
and calculated the source functions <span class="math">g_1</span> and <span class="math">g_2</span> from there. These functions
are not extremely pretty, but they are not too bad either:</p>
<div class="highlight-python"><pre>// functions g_1 and g_2
double g_1(double x, double y)
{
  return (-cos(M_PI*x/2.)*cos(M_PI*y/2.) + SIGMA*(1. - (exp(K*x) + exp(-K*x))/(exp(K) + exp(-K)))
         * (1. - (exp(K*y) + exp(-K*y))/(exp(K) + exp(-K))) + pow(M_PI,2.)*pow(D_u,2.)*cos(M_PI*x/2.)
         *cos(M_PI*y/2.)/2.);
}

double g_2(double x, double y)
{
  return ((1. - (exp(K*x) + exp(-K*x))/(exp(K) + exp(-K)))*(1. - (exp(K*y) + exp(-K*y))/(exp(K) + exp(-K)))
         - pow(D_v,2.)*(-(1 - (exp(K*x) + exp(-K*x))/(exp(K) + exp(-K)))*(pow(K,2.)*exp(K*y) + pow(K,2.)*exp(-K*y))/(exp(K) + exp(-K))
         - (1. - (exp(K*y) + exp(-K*y))/(exp(K) + exp(-K)))*(pow(K,2.)*exp(K*x) + pow(K,2.)*exp(-K*x))/(exp(K) + exp(-K))) -
         cos(M_PI*x/2.)*cos(M_PI*y/2.));

}</pre>
</div>
<p>The weak forms can be found in the
file <a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/blob/HEAD:/tutorial/11-adapt-system/forms.cpp">forms.cpp</a> and
they are registered as follows:</p>
<div class="highlight-python"><pre>// initialize the weak formulation
WeakForm wf(2);
wf.add_biform(0, 0, callback(bilinear_form_0_0));
wf.add_biform(0, 1, callback(bilinear_form_0_1));
wf.add_biform(1, 0, callback(bilinear_form_1_0));
wf.add_biform(1, 1, callback(bilinear_form_1_1));
wf.add_liform(0, linear_form_0, linear_form_0_ord);
wf.add_liform(1, linear_form_1, linear_form_1_ord);</pre>
</div>
<p>Beware that despite each of the forms is actually symmetric, one cannot use the SYM flag as in the
elasticity equations, since it has a slightly different
meaning (see example <a class="reference external" href="http://hpfem.org/hermes2d/doc/src/tutorial.html#systems-of-equations">08-system</a>).</p>
<p>The exact error is for us the maximum of the relative errors of the two solution components:</p>
<div class="highlight-python"><pre>// calculate error wrt. exact solution
ExactSolution uexact(&amp;umesh, u_exact);
ExactSolution vexact(&amp;vmesh, v_exact);
double u_error = h1_error(&amp;u_sln_coarse, &amp;uexact) * 100;
double v_error = h1_error(&amp;v_sln_coarse, &amp;vexact) * 100;
double error = fmax(u_error, v_error);
info("Exact solution error for u (H1 norm): %g%%", u_error);
info("Exact solution error for v (H1 norm): %g%%", v_error);
info("Exact solution error (maximum): %g%%", error);</pre>
</div>
<p>The next code snippet shows how we define the energy norm for adaptive
multimesh hp-FEM, whose necessity was explained in the previous
paragraph:</p>
<div class="highlight-python"><pre>// calculate element error estimates and the total error estimate
H1OrthoHP hp(2, &amp;uspace, &amp;vspace);
hp.set_biform(0, 0, bilinear_form_0_0&lt;scalar, scalar&gt;, bilinear_form_0_0&lt;Ord, Ord&gt;);
hp.set_biform(0, 1, bilinear_form_0_1&lt;scalar, scalar&gt;, bilinear_form_0_1&lt;Ord, Ord&gt;);
hp.set_biform(1, 0, bilinear_form_1_0&lt;scalar, scalar&gt;, bilinear_form_1_0&lt;Ord, Ord&gt;);
hp.set_biform(1, 1, bilinear_form_1_1&lt;scalar, scalar&gt;, bilinear_form_1_1&lt;Ord, Ord&gt;);
double err_est = hp.calc_error_2(&amp;u_sln_coarse, &amp;v_sln_coarse, &amp;u_sln_fine, &amp;v_sln_fine) * 100;
info("Estimate of error wrt. ref. solution (energy norm): %g%%", err_est);</pre>
</div>
<p>The following two figures show the solutions <span class="math">u</span> and <span class="math">v</span>. Notice their
large qualitative differences: While <span class="math">u</span> is smooth in the entire domain,
<span class="math">v</span> has a thin boundary layer along the boundary:</p>
<div align="center" class="align-center"><img alt="Solution" class="align-center" src="src/hermes2d/img/example-11/solution_u.png" style="width: 465px; height: 400px;" /></div>
<div align="center" class="align-center"><img alt="Solution" class="align-center" src="src/hermes2d/img/example-11/solution_v.png" style="width: 465px; height: 400px;" /></div>
<p>Resulting mesh for <span class="math">u</span> and <span class="math">v</span> obtained using conventional (single-mesh) hp-FEM: 12026 DOF
(6013 for each solution).</p>
<div align="center" class="align-center"><img alt="Mesh" class="align-center" src="src/hermes2d/img/example-11/mesh_single.png" style="width: 465px; height: 400px;" /></div>
<p>Resulting mesh for <span class="math">u</span> obtained using the multimesh hp-FEM: 169 DOF</p>
<div align="center" class="align-center"><img alt="Mesh" class="align-center" src="src/hermes2d/img/example-11/mesh_multi_u.png" style="width: 465px; height: 400px;" /></div>
<p>Resulting mesh for <span class="math">v</span> obtained using the multimesh hp-FEM: 3565 DOF</p>
<div align="center" class="align-center"><img alt="Mesh" class="align-center" src="src/hermes2d/img/example-11/mesh_multi_v.png" style="width: 465px; height: 400px;" /></div>
<p>DOF convergence graphs:</p>
<div align="center" class="align-center"><img alt="DOF convergence graph." class="align-center" src="src/hermes2d/img/example-11/conv_dof.png" style="width: 600px; height: 400px;" /></div>
<p>CPU time convergence graphs:</p>
<div align="center" class="align-center"><img alt="CPU convergence graph." class="align-center" src="src/hermes2d/img/example-11/conv_cpu.png" style="width: 600px; height: 400px;" /></div>
</div>
<div class="section" id="adaptivity-for-general-2nd-order-linear-equation">
<h2>Adaptivity for General 2nd-Order Linear Equation<a class="headerlink" href="#adaptivity-for-general-2nd-order-linear-equation" title="Permalink to this headline">¶</a></h2>
<p><strong>Git reference:</strong> Tutorial example <a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/tree/HEAD:/tutorial/12-adapt-general">12-adapt-general</a>.</p>
<p>This example does not bring anything substantially new and its purpose is solely to
save you work adding adaptivity to the tutorial example
<a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/tree/HEAD:/tutorial/07-general">07-general</a>.
Feel free to adjust the
<a class="reference external" href="http://hpfem.org/git/gitweb.cgi/hermes2d.git/blob/HEAD:/tutorial/12-adapt-general/main.cpp">main.cpp</a>
file for your own applications.</p>
<p>Solution:</p>
<div align="center" class="align-center"><img alt="Solution to the general 2nd-order linear equation example." class="align-center" src="src/hermes2d/img/example-12/12-solution.png" style="width: 465px; height: 400px;" /></div>
<p>Final hp-mesh:</p>
<div align="center" class="align-center"><img alt="Final finite element mesh for the general 2nd-order linear equation example." class="align-center" src="src/hermes2d/img/example-12/12-mesh.png" style="width: 450px; height: 400px;" /></div>
<p>Convergence graphs of adaptive h-FEM with linear elements, h-FEM with quadratic elements
and hp-FEM.</p>
<div align="center" class="align-center"><img alt="DOF convergence graph for tutorial example 12-adapt-general." class="align-center" src="src/hermes2d/img/example-12/conv_dof.png" style="width: 600px; height: 400px;" /></div>
<p>Convergence comparison in terms of CPU time.</p>
<div align="center" class="align-center"><img alt="CPU convergence graph for tutorial example 12-adapt-general." class="align-center" src="src/hermes2d/img/example-12/conv_cpu.png" style="width: 600px; height: 400px;" /></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Tutorial Part II (Automatic Adaptivity)</a><ul>
<li><a class="reference external" href="#adaptive-h-fem-and-hp-fem">Adaptive h-FEM and hp-FEM</a></li>
<li><a class="reference external" href="#understanding-convergence-rates">Understanding Convergence Rates</a><ul>
<li><a class="reference external" href="#algebraic-convergence-of-adaptive-fem">Algebraic convergence of adaptive <span class="math">h</span>-FEM</a></li>
<li><a class="reference external" href="#exponential-convergence-of-adaptive-fem">Exponential convergence of adaptive <span class="math">hp</span>-FEM</a></li>
<li><a class="reference external" href="#estimated-vs-exact-convergence-rates">Estimated vs. exact convergence rates</a></li>
</ul>
</li>
<li><a class="reference external" href="#electrostatic-micromotor-problem">Electrostatic Micromotor Problem</a></li>
<li><a class="reference external" href="#the-multimesh-hp-fem">The Multimesh hp-FEM</a><ul>
<li><a class="reference external" href="#adaptivity-in-the-multimesh-hp-fem">Adaptivity in the Multimesh hp-FEM</a></li>
</ul>
</li>
<li><a class="reference external" href="#simplified-fitzhugh-nagumo-system">Simplified Fitzhugh-Nagumo System</a></li>
<li><a class="reference external" href="#adaptivity-for-general-2nd-order-linear-equation">Adaptivity for General 2nd-Order Linear Equation</a></li>
</ul>
</li>
</ul>

          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Content</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, hp-FEM group at UNR.
      Last updated on Apr 22, 2010.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.3.
    </div>
  </body>
</html>